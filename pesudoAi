// export const winArr = () => { Randomizes an array
//   let jumbledWin = []
//   for (let i = 0; i < 8; i++) {
//     let index = Math.floor(Math.random() * win.length)
//     jumbledWin.push(win[index])
//     win.splice(index, 1)
//   }
//   win = jumbledWin
//   return jumbledWin
// }

let arr = [...new Set(startsNew)] (removes duplicates)

coOrds          = co-ordinates for ai to go to
mini            = playable miniGames
aiOwns          = cells owned by ai
playable        = cells not yet taken
playerOwns      = cells owned by human
win             = cells that would give ai a miniWin
deny            = cells that would deny player a miniWin
continue2       = cells that would 'continue' more than one line
continueAndNew  = cells that would continue and state a new line
continue1       = cells that would continue just one line
posLines        = cells that would start a new and available lines
safeDeadNotSafe = playableCells named according to where they would send the playar


arrays below always : from most occurred to least

continue2           = array of moves that continue 2 lines
continueAndNew      = array of moves that continue a line and start a new one 
continueAndMultiNew = array of moves that continue a line and start multiple new ordinates
continue1           = array of moves that continue only one line

make chosen miniGame smarter

if move could win main game mark as safe and take winning move
if deny sends to the same minigame, mark as safe.
if deny would prevent victory, take it.
if move would prevent victory/cause a draw, of miniGame that is crucial 
to a 'greater board' line, take move.

if move sends them to a mini with no safe moves, send them there


if no smart move can be made and a good move is available, take best/ most effective move
